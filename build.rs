use csv::ReaderBuilder;
use std::collections::HashMap;
use std::env;
use std::fs;
use std::io::Write;
use std::path::Path;

const RESIDUES: &[(&str, &str, usize, usize)] = &[
    ("ARG", "Arg", 4, 75),
    ("ASN", "Asn", 2, 36),
    ("ASP", "Asp", 2, 18),
    ("CPR", "Cpr", 3, 2),
    ("CYD", "Cyd", 1, 3),
    ("CYH", "Cyh", 1, 3),
    ("CYS", "Cys", 1, 3),
    ("GLN", "Gln", 3, 108),
    ("GLU", "Glu", 3, 54),
    ("HIS", "His", 2, 36),
    ("ILE", "Ile", 2, 9),
    ("LEU", "Leu", 2, 9),
    ("LYS", "Lys", 4, 73),
    ("MET", "Met", 3, 27),
    ("PHE", "Phe", 2, 18),
    ("PRO", "Pro", 3, 2),
    ("SER", "Ser", 1, 3),
    ("THR", "Thr", 1, 3),
    ("TPR", "Tpr", 3, 2),
    ("TRP", "Trp", 2, 36),
    ("TYR", "Tyr", 2, 18),
    ("VAL", "Val", 1, 3),
];

/// Number of grid points per axis.
const GRID_COUNT: usize = 37;

/// Grid minimum angle in degrees.
const GRID_MIN: f32 = -180.0;

/// Grid step size in degrees.
const GRID_STEP: f32 = 10.0;

/// A parsed CSV row (rotamer bin indices stored as 4 u8s, padded with 0).
#[derive(Debug, Clone)]
struct RawRow {
    r: [u8; 4],
    prob: f32,
    chi_val: [f32; 4],
    chi_sig: [f32; 4],
}

fn main() {
    println!("cargo::rerun-if-changed=data/dunbrack-2010.lib.csv");

    let csv_path = Path::new("data/dunbrack-2010.lib.csv");
    assert!(
        csv_path.exists(),
        "build.rs: CSV file not found at {csv_path:?}"
    );

    let mut tables: HashMap<String, Vec<Vec<Vec<RawRow>>>> = HashMap::new();

    let mut reader = ReaderBuilder::new()
        .has_headers(true)
        .from_path(csv_path)
        .unwrap_or_else(|e| panic!("build.rs: cannot open CSV: {e}"));

    for result in reader.records() {
        let record = result.unwrap_or_else(|e| panic!("build.rs: malformed CSV row: {e}"));

        let res: &str = &record[0];
        let phi: f32 = record[1].parse().unwrap();
        let psi: f32 = record[2].parse().unwrap();

        let r: [u8; 4] = [
            record[3].parse().unwrap(),
            record[4].parse().unwrap(),
            record[5].parse().unwrap(),
            record[6].parse().unwrap(),
        ];
        let prob: f32 = record[7].parse().unwrap();
        let chi_val: [f32; 4] = [
            record[8].parse().unwrap(),
            record[9].parse().unwrap(),
            record[10].parse().unwrap(),
            record[11].parse().unwrap(),
        ];
        let chi_sig: [f32; 4] = [
            record[12].parse().unwrap(),
            record[13].parse().unwrap(),
            record[14].parse().unwrap(),
            record[15].parse().unwrap(),
        ];

        let phi_idx = angle_to_index(phi);
        let psi_idx = angle_to_index(psi);

        let grid = tables
            .entry(res.to_string())
            .or_insert_with(|| vec![vec![Vec::new(); GRID_COUNT]; GRID_COUNT]);

        grid[phi_idx][psi_idx].push(RawRow {
            r,
            prob,
            chi_val,
            chi_sig,
        });
    }

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("tables.rs");
    let mut out = fs::File::create(&dest_path).unwrap();

    writeln!(out, "// Auto-generated by build.rs — do not edit.").unwrap();
    writeln!(out).unwrap();

    for &(csv_name, rust_name, n_chi, n_rotamers) in RESIDUES {
        let grid = tables
            .get(csv_name)
            .unwrap_or_else(|| panic!("build.rs: residue '{csv_name}' not found in CSV"));

        let table_name = format!("{}_TABLE", csv_name);

        for (phi_idx, phi_row) in grid.iter().enumerate() {
            for (psi_idx, cell) in phi_row.iter().enumerate() {
                assert!(
                    cell.len() == n_rotamers,
                    "build.rs: {csv_name} cell ({phi_idx},{psi_idx}) has {} rotamers, \
                     expected {n_rotamers}",
                    cell.len()
                );

                for row in cell {
                    assert!(
                        row.r[0] > 0,
                        "build.rs: {csv_name} cell ({phi_idx},{psi_idx}) has r1=0"
                    );
                }

                let prob_sum: f32 = cell.iter().map(|row| row.prob).sum();
                assert!(
                    (0.99..=1.01).contains(&prob_sum),
                    "build.rs: {csv_name} cell ({phi_idx},{psi_idx}) prob sum = {prob_sum:.6}"
                );
            }
        }

        for (cell_0, cell_36) in grid[0].iter().zip(grid[36].iter()) {
            assert!(
                cell_0.len() == cell_36.len(),
                "build.rs: {csv_name} φ=-180/φ=180 rotamer count mismatch"
            );

            let mut sorted_0: Vec<_> = cell_0.iter().collect();
            let mut sorted_36: Vec<_> = cell_36.iter().collect();
            sorted_0.sort_by_key(|row| row.r);
            sorted_36.sort_by_key(|row| row.r);

            for (a, b) in sorted_0.iter().zip(sorted_36.iter()) {
                assert!(
                    a.r == b.r
                        && a.prob == b.prob
                        && a.chi_val == b.chi_val
                        && a.chi_sig == b.chi_sig,
                    "build.rs: {csv_name} φ=-180/φ=180 data mismatch"
                );
            }
        }

        for (phi_idx, phi_row) in grid.iter().enumerate() {
            let cell_0 = &phi_row[0];
            let cell_36 = &phi_row[36];
            assert!(
                cell_0.len() == cell_36.len(),
                "build.rs: {csv_name} ψ=-180/ψ=180 rotamer count mismatch at φ idx {phi_idx}"
            );

            let mut sorted_0: Vec<_> = cell_0.iter().collect();
            let mut sorted_36: Vec<_> = cell_36.iter().collect();
            sorted_0.sort_by_key(|row| row.r);
            sorted_36.sort_by_key(|row| row.r);

            for (a, b) in sorted_0.iter().zip(sorted_36.iter()) {
                assert!(
                    a.r == b.r
                        && a.prob == b.prob
                        && a.chi_val == b.chi_val
                        && a.chi_sig == b.chi_sig,
                    "build.rs: {csv_name} ψ=-180/ψ=180 data mismatch at φ idx {phi_idx}"
                );
            }
        }

        let mut sorted_grid: Vec<Vec<Vec<&RawRow>>> =
            vec![vec![Vec::new(); GRID_COUNT]; GRID_COUNT];

        for (phi_idx, phi_row) in grid.iter().enumerate() {
            for (psi_idx, cell) in phi_row.iter().enumerate() {
                let mut sorted: Vec<&RawRow> = cell.iter().collect();
                sorted.sort_by_key(|row| row.r);
                sorted_grid[phi_idx][psi_idx] = sorted;
            }
        }

        let canonical_keys: Vec<[u8; 4]> = sorted_grid[0][0].iter().map(|row| row.r).collect();
        for (phi_idx, phi_row) in sorted_grid.iter().enumerate() {
            for (psi_idx, cell) in phi_row.iter().enumerate() {
                let cell_keys: Vec<[u8; 4]> = cell.iter().map(|row| row.r).collect();
                assert!(
                    cell_keys == canonical_keys,
                    "build.rs: {csv_name} cell ({phi_idx},{psi_idx}) has different \
                     r[] key set than cell (0,0)"
                );
            }
        }

        emit_table(&mut out, &table_name, n_chi, n_rotamers, &sorted_grid);

        emit_impl(&mut out, rust_name, &table_name, n_chi, n_rotamers);
    }
}

/// Converts a grid angle (-180..180, step 10) to a table index (0..36).
fn angle_to_index(deg: f32) -> usize {
    let idx = ((deg - GRID_MIN) / GRID_STEP).round() as usize;
    assert!(idx < GRID_COUNT, "build.rs: angle {deg}° out of grid range");
    idx
}

/// Emits a `static TABLE: [[[Rotamer<N>; R]; 37]; 37]` declaration.
fn emit_table(
    out: &mut fs::File,
    table_name: &str,
    n_chi: usize,
    n_rotamers: usize,
    grid: &[Vec<Vec<&RawRow>>],
) {
    writeln!(
        out,
        "static {table_name}: [[[crate::rotamer::Rotamer<{n_chi}>; {n_rotamers}]; \
         {GRID_COUNT}]; {GRID_COUNT}] = ["
    )
    .unwrap();

    for phi_row in grid.iter() {
        writeln!(out, "[").unwrap();
        for cell in phi_row.iter() {
            writeln!(out, "[").unwrap();
            for row in cell.iter() {
                emit_rotamer(out, row, n_chi);
            }
            writeln!(out, "],").unwrap();
        }
        writeln!(out, "],").unwrap();
    }

    writeln!(out, "];").unwrap();
    writeln!(out).unwrap();
}

/// Emits a single `Rotamer { r, prob, chi_mean, chi_sigma }` literal.
fn emit_rotamer(out: &mut fs::File, row: &RawRow, n_chi: usize) {
    write!(out, "crate::rotamer::Rotamer {{ r: [").unwrap();
    for i in 0..n_chi {
        if i > 0 {
            write!(out, ", ").unwrap();
        }
        write!(out, "{}", row.r[i]).unwrap();
    }
    write!(out, "], ").unwrap();

    write!(out, "prob: {}_f32, ", format_f32(row.prob)).unwrap();

    write!(out, "chi_mean: [").unwrap();
    for i in 0..n_chi {
        if i > 0 {
            write!(out, ", ").unwrap();
        }
        write!(out, "{}_f32", format_f32(row.chi_val[i])).unwrap();
    }
    write!(out, "], ").unwrap();

    write!(out, "chi_sigma: [").unwrap();
    for i in 0..n_chi {
        if i > 0 {
            write!(out, ", ").unwrap();
        }
        write!(out, "{}_f32", format_f32(row.chi_sig[i])).unwrap();
    }
    writeln!(out, "] }},").unwrap();
}

/// Formats an f32 with the shortest representation that round-trips exactly.
fn format_f32(v: f32) -> String {
    format!("{v:?}")
}

/// Emits `impl sealed::Sealed for X {}` and `impl Residue for X { … }`.
fn emit_impl(
    out: &mut fs::File,
    rust_name: &str,
    table_name: &str,
    n_chi: usize,
    n_rotamers: usize,
) {
    writeln!(
        out,
        "impl crate::sealed::Sealed for crate::residue::{rust_name} {{}}"
    )
    .unwrap();

    writeln!(
        out,
        "impl crate::residue::Residue for crate::residue::{rust_name} {{"
    )
    .unwrap();
    writeln!(out, "    const N_CHI: usize = {n_chi};").unwrap();
    writeln!(out, "    const N_ROTAMERS: usize = {n_rotamers};").unwrap();
    writeln!(out, "    type Rot = crate::rotamer::Rotamer<{n_chi}>;").unwrap();
    writeln!(
        out,
        "    type Iter = crate::interp::RotamerIter<{n_chi}, {n_rotamers}>;"
    )
    .unwrap();
    writeln!(out, "    #[inline]").unwrap();
    writeln!(
        out,
        "    fn rotamers(phi: f32, psi: f32) -> crate::interp::RotamerIter<{n_chi}, {n_rotamers}> {{"
    )
    .unwrap();
    writeln!(
        out,
        "        crate::interp::build_iter(&{table_name}, phi, psi)"
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out).unwrap();
}
